name: RDP

on:
  workflow_dispatch:

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 3600

    steps:
      - name: Configure Core RDP Settings
        run: |
          # Enable Remote Desktop and disable Network Level Authentication (if needed)
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                             -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
                             -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
                             -Name "SecurityLayer" -Value 0 -Force

          # Remove any existing rule with the same name to avoid duplication
          netsh advfirewall firewall delete rule name="RDP-Tailscale"
          
          # For testing, allow any incoming connection on port 3389
          netsh advfirewall firewall add rule name="RDP-Tailscale" `
            dir=in action=allow protocol=TCP localport=3389

          # (Optional) Restart the Remote Desktop service to ensure changes take effect
          Restart-Service -Name TermService -Force

      - name: Create RDP User with Secure Password
        run: |
          Add-Type -AssemblyName System.Security
          $charSet = @{
              Upper   = [char[]](65..90)      # A-Z
              Lower   = [char[]](97..122)     # a-z
              Number  = [char[]](48..57)      # 0-9
              Special = ([char[]](33..47) + [char[]](58..64) +
                         [char[]](91..96) + [char[]](123..126)) # Special characters
          }
          $rawPassword = @()
          $rawPassword += $charSet.Upper | Get-Random -Count 4
          $rawPassword += $charSet.Lower | Get-Random -Count 4
          $rawPassword += $charSet.Number | Get-Random -Count 4
          $rawPassword += $charSet.Special | Get-Random -Count 4
          $password = -join ($rawPassword | Sort-Object { Get-Random })
          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          New-LocalUser -Name "RDP" -Password $securePass -AccountNeverExpires
          Add-LocalGroupMember -Group "Administrators" -Member "RDP"
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member "RDP"
          
          echo "RDP_CREDS=User: RDP | Password: $password" >> $env:GITHUB_ENV
          
          if (-not (Get-LocalUser -Name "RDP")) {
              Write-Error "User creation failed"
              exit 1
          }

      - name: Install Tailscale
        run: |
          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-1.82.0-amd64.msi"
          $installerPath = "$env:TEMP\tailscale.msi"
          
          Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath
          Start-Process msiexec.exe -ArgumentList "/i", "`"$installerPath`"", "/quiet", "/norestart" -Wait
          Remove-Item $installerPath -Force

      - name: Establish Tailscale Connection
        run: |
          # Bring up Tailscale with the provided auth key and set a unique hostname
          & "$env:ProgramFiles\Tailscale\tailscale.exe" up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=gh-runner-$env:GITHUB_RUN_ID
          
          # Wait for Tailscale to assign an IP
          $tsIP = $null
          $retries = 0
          while (-not $tsIP -and $retries -lt 10) {
              $tsIP = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
              Start-Sleep -Seconds 5
              $retries++
          }
          
          if (-not $tsIP) {
              Write-Error "Tailscale IP not assigned. Exiting."
              exit 1
          }
          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV
      
      - name: Verify RDP Accessibility
        run: |
          Write-Host "Tailscale IP: $env:TAILSCALE_IP"
          
          # Test connectivity using Test-NetConnection against the Tailscale IP on port 3389
          $testResult = Test-NetConnection -ComputerName $env:TAILSCALE_IP -Port 3389
          if (-not $testResult.TcpTestSucceeded) {
              Write-Error "TCP connection to RDP port 3389 failed"
              exit 1
          }
          Write-Host "TCP connectivity successful!"

      - name: Create Backup Directory
        run: |
          $backupDir = "$env:GITHUB_WORKSPACE\backup"
          New-Item -ItemType Directory -Path $backupDir -Force
          New-Item -ItemType Directory -Path "$backupDir\Programs" -Force
          New-Item -ItemType Directory -Path "$backupDir\ProgramData" -Force
          echo "BACKUP_DIR=$backupDir" >> $env:GITHUB_ENV

      - name: Maintain Connection
        run: |
          Write-Host "`n=== RDP ACCESS ==="
          Write-Host "Address: $env:TAILSCALE_IP"
          Write-Host "Username: RDP"
          Write-Host "Password: $(echo $env:RDP_CREDS)"
          Write-Host "==================`n"
          
          # Keep runner active indefinitely (or until manually cancelled)
          while ($true) {
              Write-Host "[$(Get-Date)] RDP Active - Use Ctrl+C in workflow to terminate"
              Start-Sleep -Seconds 300
          }

      - name: Export Installed Programs List
        if: always()
        run: |
          Write-Host "Exporting installed programs list..."
          $backupDir = $env:BACKUP_DIR
          
          # Export installed programs from registry (64-bit)
          Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*" |
            Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation |
            Where-Object { $_.DisplayName } |
            Export-Csv "$backupDir\Programs\installed_programs_x64.csv" -NoTypeInformation
          
          # Export installed programs from registry (32-bit)
          Get-ItemProperty "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" |
            Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation |
            Where-Object { $_.DisplayName } |
            Export-Csv "$backupDir\Programs\installed_programs_x86.csv" -NoTypeInformation
          
          # Export user-installed programs
          Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*" |
            Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation |
            Where-Object { $_.DisplayName } |
            Export-Csv "$backupDir\Programs\installed_programs_user.csv" -NoTypeInformation
          
          # Export Windows features
          Get-WindowsOptionalFeature -Online |
            Where-Object { $_.State -eq "Enabled" } |
            Select-Object FeatureName, State |
            Export-Csv "$backupDir\Programs\windows_features.csv" -NoTypeInformation
          
          Write-Host "Programs list exported!"

      - name: Backup Portable Programs
        if: always()
        run: |
          Write-Host "Backing up portable programs..."
          $backupDir = $env:BACKUP_DIR
          
          # Lista de diretórios comuns para programas portáteis
          $portableDirs = @(
              "$env:USERPROFILE\PortableApps",
              "$env:USERPROFILE\Desktop\PortableApps",
              "C:\PortableApps",
              "$env:GITHUB_WORKSPACE\apps",
              "$env:GITHUB_WORKSPACE\programs"
          )
          
          foreach ($dir in $portableDirs) {
              if (Test-Path $dir) {
                  $dirName = Split-Path $dir -Leaf
                  Write-Host "Backing up: $dir"
                  Copy-Item -Path $dir -Destination "$backupDir\Programs\$dirName" -Recurse -Force -ErrorAction SilentlyContinue
              }
          }
          
          Write-Host "Portable programs backup completed!"

      - name: Backup Program Data and Configurations
        if: always()
        run: |
          Write-Host "Backing up program data and configurations..."
          $backupDir = $env:BACKUP_DIR
          
          # Backup AppData Local
          $appDataLocal = "$env:LOCALAPPDATA"
          if (Test-Path $appDataLocal) {
              Write-Host "Backing up AppData Local..."
              # Lista de pastas importantes (ajuste conforme necessário)
              $importantApps = @("Google", "Microsoft", "Mozilla", "Discord", "Slack", "Telegram", "Programs")
              foreach ($app in $importantApps) {
                  $appPath = Join-Path $appDataLocal $app
                  if (Test-Path $appPath) {
                      Copy-Item -Path $appPath -Destination "$backupDir\ProgramData\AppData_Local\$app" -Recurse -Force -ErrorAction SilentlyContinue
                  }
              }
          }
          
          # Backup AppData Roaming
          $appDataRoaming = "$env:APPDATA"
          if (Test-Path $appDataRoaming) {
              Write-Host "Backing up AppData Roaming..."
              foreach ($app in $importantApps) {
                  $appPath = Join-Path $appDataRoaming $app
                  if (Test-Path $appPath) {
                      Copy-Item -Path $appPath -Destination "$backupDir\ProgramData\AppData_Roaming\$app" -Recurse -Force -ErrorAction SilentlyContinue
                  }
              }
          }
          
          # Backup ProgramData comum
          $commonProgramData = "C:\ProgramData"
          $programDataApps = @("Microsoft", "Package Cache")
          foreach ($app in $programDataApps) {
              $appPath = Join-Path $commonProgramData $app
              if (Test-Path $appPath) {
                  Copy-Item -Path $appPath -Destination "$backupDir\ProgramData\CommonProgramData\$app" -Recurse -Force -ErrorAction SilentlyContinue
              }
          }
          
          Write-Host "Program data backup completed!"

      - name: Backup Chocolatey Packages
        if: always()
        run: |
          Write-Host "Checking for Chocolatey..."
          $backupDir = $env:BACKUP_DIR
          
          if (Test-Path "C:\ProgramData\chocolatey\bin\choco.exe") {
              Write-Host "Chocolatey found! Exporting package list..."
              & "C:\ProgramData\chocolatey\bin\choco.exe" list --local-only > "$backupDir\Programs\chocolatey_packages.txt"
              
              # Export with versions for easy reinstall
              & "C:\ProgramData\chocolatey\bin\choco.exe" export "$backupDir\Programs\chocolatey_packages.config"
          } else {
              Write-Host "Chocolatey not installed, skipping..."
          }

      - name: Backup Scoop Packages
        if: always()
        run: |
          Write-Host "Checking for Scoop..."
          $backupDir = $env:BACKUP_DIR
          
          if (Test-Path "$env:USERPROFILE\scoop\shims\scoop.cmd") {
              Write-Host "Scoop found! Exporting package list..."
              & "$env:USERPROFILE\scoop\shims\scoop.cmd" export > "$backupDir\Programs\scoop_packages.json"
              
              # Backup Scoop apps directory
              if (Test-Path "$env:USERPROFILE\scoop\apps") {
                  Copy-Item -Path "$env:USERPROFILE\scoop\apps" -Destination "$backupDir\Programs\scoop_apps" -Recurse -Force -ErrorAction SilentlyContinue
              }
          } else {
              Write-Host "Scoop not installed, skipping..."
          }

      - name: Create Reinstall Script
        if: always()
        run: |
          Write-Host "Creating reinstall script..."
          $backupDir = $env:BACKUP_DIR
          
          $reinstallScript = @"
# Script de reinstalação automática de programas
# Execute como Administrador

Write-Host "=== Script de Reinstalação de Programas ===" -ForegroundColor Green

# Instalar Chocolatey se necessário
if (-not (Test-Path "C:\ProgramData\chocolatey\bin\choco.exe")) {
    Write-Host "Instalando Chocolatey..." -ForegroundColor Yellow
    Set-ExecutionPolicy Bypass -Scope Process -Force
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
}

# Reinstalar pacotes Chocolatey
if (Test-Path ".\Programs\chocolatey_packages.config") {
    Write-Host "Reinstalando pacotes Chocolatey..." -ForegroundColor Yellow
    choco install ".\Programs\chocolatey_packages.config" -y
}

# Instalar Scoop se necessário
if (-not (Test-Path "$env:USERPROFILE\scoop\shims\scoop.cmd")) {
    Write-Host "Instalando Scoop..." -ForegroundColor Yellow
    Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
}

# Reinstalar pacotes Scoop
if (Test-Path ".\Programs\scoop_packages.json") {
    Write-Host "Reinstalando pacotes Scoop..." -ForegroundColor Yellow
    Get-Content ".\Programs\scoop_packages.json" | ConvertFrom-Json | ForEach-Object {
        scoop install $_.Name
    }
}

Write-Host "`n=== Lista de Programas Instalados ===" -ForegroundColor Green
Write-Host "Verifique os arquivos CSV na pasta Programs para ver todos os programas que estavam instalados."
Write-Host "`nArquivos disponíveis:"
Get-ChildItem ".\Programs\*.csv" | ForEach-Object { Write-Host "  - $($_.Name)" }

Write-Host "`n=== Concluído! ===" -ForegroundColor Green
"@
          
          $reinstallScript | Out-File -FilePath "$backupDir\REINSTALL_PROGRAMS.ps1" -Encoding UTF8
          Write-Host "Reinstall script created!"

      - name: Backup User Data
        if: always()
        run: |
          Write-Host "Starting user data backup..."
          $backupDir = $env:BACKUP_DIR
          
          # Backup Desktop
          if (Test-Path "C:\Users\RDP\Desktop") {
              Copy-Item -Path "C:\Users\RDP\Desktop\*" -Destination "$backupDir\Desktop" -Recurse -Force -ErrorAction SilentlyContinue
          }
          
          # Backup Documents
          if (Test-Path "C:\Users\RDP\Documents") {
              Copy-Item -Path "C:\Users\RDP\Documents\*" -Destination "$backupDir\Documents" -Recurse -Force -ErrorAction SilentlyContinue
          }
          
          # Backup Downloads
          if (Test-Path "C:\Users\RDP\Downloads") {
              Copy-Item -Path "C:\Users\RDP\Downloads\*" -Destination "$backupDir\Downloads" -Recurse -Force -ErrorAction SilentlyContinue
          }
          
          # Backup any custom directories in workspace
          if (Test-Path "$env:GITHUB_WORKSPACE\data") {
              Copy-Item -Path "$env:GITHUB_WORKSPACE\data\*" -Destination "$backupDir\workspace_data" -Recurse -Force -ErrorAction SilentlyContinue
          }
          
          Write-Host "User data backup completed!"

      - name: Generate Backup Report
        if: always()
        run: |
          Write-Host "Generating backup report..."
          $backupDir = $env:BACKUP_DIR
          
          $report = @"
=== RELATÓRIO DE BACKUP ===
Data: $(Get-Date -Format "dd/MM/yyyy HH:mm:ss")
Run ID: $env:GITHUB_RUN_ID

PROGRAMAS INSTALADOS:
"@
          
          if (Test-Path "$backupDir\Programs\installed_programs_x64.csv") {
              $count = (Import-Csv "$backupDir\Programs\installed_programs_x64.csv").Count
              $report += "`n- Programas 64-bit: $count"
          }
          
          if (Test-Path "$backupDir\Programs\installed_programs_x86.csv") {
              $count = (Import-Csv "$backupDir\Programs\installed_programs_x86.csv").Count
              $report += "`n- Programas 32-bit: $count"
          }
          
          if (Test-Path "$backupDir\Programs\chocolatey_packages.txt") {
              $report += "`n- Chocolatey: Sim"
          }
          
          if (Test-Path "$backupDir\Programs\scoop_packages.json") {
              $report += "`n- Scoop: Sim"
          }
          
          $report += "`n`nDIRETÓRIOS BACKUP:"
          Get-ChildItem $backupDir -Directory | ForEach-Object {
              $size = (Get-ChildItem $_.FullName -Recurse -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum / 1MB
              $report += "`n- $($_.Name): $([math]::Round($size, 2)) MB"
          }
          
          $report | Out-File -FilePath "$backupDir\BACKUP_REPORT.txt" -Encoding UTF8
          Write-Host $report
          Write-Host "`nBackup report generated!"

      - name: Compress Backup
        if: always()
        run: |
          $backupDir = $env:BACKUP_DIR
          $archivePath = "$env:GITHUB_WORKSPACE\backup-$(Get-Date -Format 'yyyyMMdd-HHmmss').zip"
          
          if (Test-Path $backupDir) {
              Write-Host "Compressing backup... This may take a while..."
              Compress-Archive -Path "$backupDir\*" -DestinationPath $archivePath -CompressionLevel Optimal -Force
              
              $archiveSize = (Get-Item $archivePath).Length / 1MB
              Write-Host "Backup compressed to: $archivePath"
              Write-Host "Archive size: $([math]::Round($archiveSize, 2)) MB"
              
              echo "BACKUP_ARCHIVE=$archivePath" >> $env:GITHUB_ENV
          }

      - name: Upload Backup as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rdp-backup-${{ github.run_id }}
          path: ${{ env.BACKUP_ARCHIVE }}
          retention-days: 30
          compression-level: 0
          if-no-files-found: warn

      - name: Cleanup
        if: always()
        run: |
          Write-Host "Cleaning up..."
          
          # Disconnect Tailscale
          & "$env:ProgramFiles\Tailscale\tailscale.exe" down
          
          # Remove RDP user
          Remove-LocalUser -Name "RDP" -ErrorAction SilentlyContinue
          
          Write-Host "Cleanup completed!"
